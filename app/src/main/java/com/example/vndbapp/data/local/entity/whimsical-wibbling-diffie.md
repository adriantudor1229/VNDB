# VNDB Android App - Comprehensive Improvement Plan

> Generated by The Hermit (Cattleya) with Eye of Mystery Prying
> Critical review by The Hanged Man

---

## Overview

This plan addresses **16 identified issues** across 4 severity levels. The application follows Clean Architecture patterns but has critical flaws in error handling, dependency management, and testability.

**Severity Summary:**
- CRITICAL: 4 issues (error handling, coupling, UI states)
- MEDIUM: 8 issues (architecture, testing, configuration)
- LOW: 4 issues (code cleanup, responsiveness)

---

## Phase 1: CRITICAL Fixes (Must Fix Before Production)

### Fix #1: Implement Resource/Result Wrapper for Error Handling

**Problem**: `LocalVisualNovelRepositoryImpl.kt:36-38` silently swallows exceptions with only `printStackTrace()`.

**Current Code:**
```kotlin
// data/local/repository/LocalVisualNovelRepositoryImpl.kt
override suspend fun getVisualNovelsByPage(page: Int): Flow<List<VisualNovelEntity>> {
    val cachedCount = visualNovelDao.getPageCount(page)
    if (cachedCount == 0) {
        try {
            val vns = visualNovelApiService.getVisualNovels(...)
            vns.body()?.results.let { results ->
                val entities = results?.map { it.toEntity(page = page) }
                visualNovelDao.insertVisualNovels(vns = entities ?: emptyList())
            }
        } catch (e: Exception) {
            e.printStackTrace()  // ❌ Silent failure
        }
    }
    return visualNovelDao.getVisualNovelsByPage(page = page)
}
```

**Solution:**

**Step 1:** Create `Resource.kt` wrapper in `data/model/`:
```kotlin
// data/model/Resource.kt
sealed class Resource<out T> {
    data class Success<T>(val data: T) : Resource<T>()
    data class Error(val message: String, val cause: Throwable? = null) : Resource<Nothing>()
    data object Loading : Resource<Nothing>()
}
```

**Step 2:** Update repository to return `Resource`:
```kotlin
// data/local/repository/LocalVisualNovelRepository.k
interface LocalVisualNovelRepository {
    suspend fun getVisualNovelsByPage(page: Int): Flow<Resource<List<VisualNovelEntity>>>
    suspend fun saveVisualNovels(vns: List<VisualNovel>, page: Int): Resource<Unit>
}
```

**Step 3:** Implement with proper error handling:
```kotlin
// data/local/repository/LocalVisualNovelRepositoryImpl.kt
override suspend fun getVisualNovelsByPage(page: Int): Flow<Resource<List<VisualNovelEntity>> = flow {
    emit(Resource.Loading)

    val cachedCount = visualNovelDao.getPageCount(page)

    if (cachedCount == 0) {
        try {
            val response = visualNovelApiService.getVisualNovels(
                requestBodyVisualNovel = RequestBodyVisualNovel(
                    page = page,
                    fields = ApiConstants.FIELDS,
                    filters = emptyList()
                )
            )

            if (response.isSuccessful && response.body() != null) {
                val results = response.body()!!.results
                if (results != null) {
                    val entities = results.map { it.toEntity(page = page) }
                    visualNovelDao.insertVisualNovels(entities)
                }
            } else {
                val errorMsg = "API Error: ${response.code()} - ${response.message()}"
                emit(Resource.Error(errorMsg))
                return@flow
            }
        } catch (e: IOException) {
            emit(Resource.Error("Network error: ${e.message}", e))
            return@flow
        } catch (e: HttpException) {
            emit(Resource.Error("HTTP error: ${e.message}", e))
            return@flow
        } catch (e: Exception) {
            emit(Resource.Error("Unexpected error: ${e.message}", e))
            return@flow
        }
    }

    val data = visualNovelDao.getVisualNovelsByPage(page = page).first()
    emit(Resource.Success(data))
}
```

---

### Fix #2: Fix ViewModel Dependency Inversion Violation

**Problem**: `VisualNovelViewModel.kt:19` depends on concrete implementation instead of interface.

**Current Code:**
```kotlin
// presentation/viewmodel/VisualNovelViewModel.kt
@HiltViewModel
class VisualNovelViewModel @Inject constructor(
    private val localVisualNovelRepositoryImpl: LocalVisualNovelRepositoryImpl  // ❌ Concrete
) : ViewModel()
```

**Solution:**
```kotlin
// presentation/viewmodel/VisualNovelViewModel.kt
@HiltViewModel
class VisualNovelViewModel @Inject constructor(
    private val localVisualNovelRepository: LocalVisualNovelRepository  // ✅ Interface
) : ViewModel() {
    private val _currentPage = MutableStateFlow(0)

    val currentPageVns: StateFlow<Resource<List<VisualNovelEntity>>> =
        _currentPage.flatMapLatest { page ->
            localVisualNovelRepository.getVisualNovelsByPage(page = page)
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = Resource.Loading
        )

    fun loadPage(page: Int) {
        _currentPage.value = page
    }
}
```

---

### Fix #3: Update UI to Handle Resource States

**Problem**: UI has no way to distinguish between Loading, Success, or Error states.

**Current Code:**
```kotlin
// presentation/screens/VisualNovelScreen.kt
@Composable
private fun VisualNovelListContent(...) {
    val visualNovels by viewModel.currentPageVns.collectAsState()
    // Only List<VisualNovelEntity>, no state info
}
```

**Solution:**
```kotlin
// presentation/screens/VisualNovelScreen.kt
@Composable
private fun VisualNovelListContent(
    modifier: Modifier = Modifier,
    onNavigateToDetail: (VisualNovel) -> Unit,
    viewModel: VisualNovelViewModel = hiltViewModel(),
) {
    val pagerState = rememberPagerState(pageCount = { 10 }, initialPage = 0)
    val resource by viewModel.currentPageVns.collectAsState()

    LaunchedEffect(pagerState.currentPage) {
        val pageNumber = pagerState.currentPage + 1
        viewModel.loadPage(page = pageNumber)
    }

    HorizontalPager(state = pagerState, modifier = modifier) { page ->
        when (resource) {
            is Resource.Loading -> {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }
            is Resource.Success -> {
                val visualNovels = (resource as Resource.Success).data
                VisualNovelGrid(
                    visualNovels = visualNovels.map { it.toModel() },
                    onNavigateToDetail = onNavigateToDetail,
                    modifier = modifier
                )
            }
            is Resource.Error -> {
                val error = resource as Resource.Error
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                            text = "Error loading visual novels",
                            color = MaterialTheme.colorScheme.error
                        )
                        Text(
                            text = error.message,
                            style = MaterialTheme.typography.bodySmall
                        )
                        Button(onClick = { viewModel.loadPage(page + 1) }) {
                            Text("Retry")
                        }
                    }
                }
            }
        }
    }
}
```

---

### Fix #4: Add Proper Logging

**Problem**: Using `printStackTrace()` which is useless in production.

**Current Code:**
```kotlin
} catch (e: Exception) {
    e.printStackTrace()  // ❌ No visibility in production
}
```

**Solution:**

**Step 1:** Add Timber to `build.gradle.kts`:
```kotlin
implementation("com.jakewharton.timber:timber:5.0.1")
```

**Step 2:** Initialize in Application class:
```kotlin
// VNDBApplication.kt
import timber.log.Timber

class VNDBApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        if (BuildConfig.DEBUG) {
            Timber.plant(Timber.DebugTree())
        }
    }
}
```

**Step 3:** Use Timber instead of printStackTrace:
```kotlin
} catch (e: IOException) {
    Timber.e(e, "Network error fetching page %d", page)
    emit(Resource.Error("Network error: ${e.message}", e))
}
```

---

## Phase 2: HIGH PRIORITY (Architecture Stability)

### Fix #5: Unify Repositories - Single Source of Truth

**Problem**: Two separate repositories (`LocalVisualNovelRepositoryImpl` and `VisualNovelRepositoryImpl`) with unclear responsibilities.

**Current Structure:**
```
LocalVisualNovelRepositoryImpl → Handles BOTH cache AND network
VisualNovelRepositoryImpl → Thin wrapper over API (no clear purpose)
```

**Solution:** Consolidate into single `VisualNovelRepository`:

**Step 1:** Create unified interface:
```kotlin
// data/repository/VisualNovelRepository.kt
interface VisualNovelRepository {
    suspend fun getVisualNovelsByPage(page: Int): Flow<Resource<List<VisualNovelEntity>>>
    suspend fun refreshVisualNovels(page: Int): Resource<Unit>
    suspend fun getVisualNovelById(id: String): Flow<Resource<VisualNovelEntity?>>
}
```

**Step 2:** Unified implementation:
```kotlin
// data/repository/VisualNovelRepositoryImpl.kt
class VisualNovelRepositoryImpl @Inject constructor(
    private val visualNovelDao: VisualNovelDao,
    private val visualNovelApiService: VisualNovelApiService,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) : VisualNovelRepository {

    override suspend fun getVisualNovelsByPage(page: Int): Flow<Resource<List<VisualNovelEntity>>> = flow {
        emit(Resource.Loading)

        // First, emit cached data if available
        val cached = visualNovelDao.getVisualNovelsByPage(page).first()
        if (cached.isNotEmpty()) {
            emit(Resource.Success(cached))
        }

        // Then refresh from network
        try {
            val response = visualNovelApiService.getVisualNovels(
                RequestBodyVisualNovel(
                    page = page,
                    fields = ApiConstants.FIELDS,
                    filters = emptyList()
                )
            )

            if (response.isSuccessful && response.body() != null) {
                val results = response.body()!!.results ?: emptyList()
                val entities = results.map { it.toEntity(page = page) }
                withContext(ioDispatcher) {
                    visualNovelDao.insertVisualNovels(entities)
                }
                emit(Resource.Success(entities))
            } else {
                if (cached.isEmpty()) {
                    emit(Resource.Error("API Error: ${response.code()}"))
                }
            }
        } catch (e: Exception) {
            Timber.e(e, "Error fetching visual novels")
            if (cached.isEmpty()) {
                emit(Resource.Error("Failed to load: ${e.message}", e))
            }
        }
    }

    override suspend fun refreshVisualNovels(page: Int): Resource<Unit> {
        return try {
            val response = visualNovelApiService.getVisualNovels(
                RequestBodyVisualNovel(page, ApiConstants.FIELDS, emptyList())
            )
            if (response.isSuccessful && response.body() != null) {
                val results = response.body()!!.results ?: emptyList()
                val entities = results.map { it.toEntity(page) }
                visualNovelDao.insertVisualNovels(entities)
                Resource.Success(Unit)
            } else {
                Resource.Error("API Error: ${response.code()}")
            }
        } catch (e: Exception) {
            Timber.e(e, "Error refreshing page %d", page)
            Resource.Error("Failed to refresh: ${e.message}", e)
        }
    }

    override suspend fun getVisualNovelById(id: String): Flow<Resource<VisualNovelEntity?>> = flow {
        emit(Resource.Loading)
        try {
            val vn = visualNovelDao.getVisualNovelById(id)
            emit(Resource.Success(vn))
        } catch (e: Exception) {
            emit(Resource.Error("Failed to load: ${e.message}", e))
        }
    }
}
```

**Step 3:** Delete old files:
- `data/local/repository/LocalVisualNovelRepository.kt`
- `data/local/repository/LocalVisualNovelRepositoryImpl.kt`
- `data/remote/repository/VisualNovelRepository.kt`
- `data/remote/repository/VisualNovelRepositoryImpl.kt`

**Step 4:** Update DI module:
```kotlin
// di/AppModule.kt
@Module
@InstallIn(SingletonComponent::class)
abstract class AppModule {
    @Binds
    abstract fun bindVisualNovelRepository(
        impl: VisualNovelRepositoryImpl
    ): VisualNovelRepository
}
```

---

### Fix #6: Add Domain Layer with Use Cases

**Problem**: Business logic scattered across repositories and UI.

**Solution:**

**Step 1:** Create use case interface:
```kotlin
// domain/usecase/GetVisualNovelsByPageUseCase.kt
class GetVisualNovelsByPageUseCase @Inject constructor(
    private val repository: VisualNovelRepository
) {
    operator fun invoke(page: Int): Flow<Resource<List<VisualNovel>>> {
        return repository.getVisualNovelsByPage(page).map { resource ->
            when (resource) {
                is Resource.Success -> {
                    val filtered = resource.data
                        .filter { it.explicit < Constants.MAX_EXPLICIT_CONTENT_THRESHOLD }
                        .map { it.toModel() }
                    Resource.Success(filtered)
                }
                is Resource.Error -> resource
                is Resource.Loading -> resource
            }
        }
    }
}
```

**Step 2:** Add domain constants:
```kotlin
// domain/util/Constants.kt
object Constants {
    const val MAX_EXPLICIT_CONTENT_THRESHOLD = 0.4
    const val DEFAULT_GRID_COLUMNS = 2
    const val MAX_PAGES = 10
}
```

**Step 3:** Update ViewModel to use use case:
```kotlin
// presentation/viewmodel/VisualNovelViewModel.kt
@HiltViewModel
class VisualNovelViewModel @Inject constructor(
    private val getVisualNovelsByPageUseCase: GetVisualNovelsByPageUseCase
) : ViewModel() {
    private val _currentPage = MutableStateFlow(0)

    val currentPageVns: StateFlow<Resource<List<VisualNovel>>> =
        _currentPage.flatMapLatest { page ->
            getVisualNovelsByPageUseCase(page)
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = Resource.Loading
        )

    fun loadPage(page: Int) {
        _currentPage.value = page
    }
}
```

---

### Fix #7: Remove Dead Code

**Problem:** `VisualNovelEvent.kt` is defined but never used.

**Solution:** Delete the file:
```kotlin
// DELETE: presentation/viewmodel/VisualNovelEvent.kt
// This file contains:
sealed class VisualNovelEvent {
    data object NavigateToDetail : VisualNovelEvent()
    data object ShowError : VisualNovelEvent()
}
// But it's never used anywhere.
```

---

## Phase 3: MEDIUM PRIORITY (Code Quality)

### Fix #8: Choose One Serialization Library

**Problem**: Using both Moshi and kotlinx.serialization on same classes.

**Current Code:**
```kotlin
// data/model/VisualNovel.kt
import com.squareup.moshi.Json
import kotlinx.serialization.Serializable

@Serializable  // kotlinx.serialization
data class VisualNovel(...)

@Serializable
data class Image(...) {
    @param:Json(name = "sexual")  // Moshi annotation
    val explicit: Double
}
```

**Solution:** Use kotlinx.serialization (recommended for Kotlin):

**Step 1:** Remove Moshi from `build.gradle.kts`:
```kotlin
// REMOVE these:
implementation("com.squareup.moshi:moshi:1.15.0")
implementation("com.squareup.moshi:moshi-kotlin:1.15.0")
ksp("com.squareup.moshi:moshi-kotlin-codegen:1.15.0")
```

**Step 2:** Update model with kotlinx.serialization:
```kotlin
// data/model/VisualNovel.kt
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
data class VisualNovel(
    val title: String,
    val image: Image,
    val id: String,
    val description: String
)

@Serializable
data class Image(
    val url: String? = null,
    val thumbnail: String? = null,
    @SerialName("sexual")
    val explicit: Double
)

@Serializable
data class RequestBodyVisualNovel(
    val fields: String,
    val page: Int,
    val filters: List<String>
)

@Serializable
data class VisualNovelResponse(
    val results: List<VisualNovel>,
    val more: Boolean
)
```

**Step 3:** Update RetrofitModule to use kotlinx.serialization:
```kotlin
// di/RetrofitModule.kt
@Module
@InstallIn(SingletonComponent::class)
object RetrofitModule {

    @Provides
    @Singleton
    fun provideKotlinSerializationConverterFactory(): Converter.Factory {
        val json = Json {
            ignoreUnknownKeys = true
            coerceInputValues = true
        }
        return json.asConverterFactory("application/json".toMediaType())
    }

    @Provides
    @Singleton
    fun provideRetrofit(
        okHttpClient: OkHttpClient,
        converterFactory: Converter.Factory
    ): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.vndb.org/kana/")
            .client(okHttpClient)
            .addConverterFactory(converterFactory)
            .build()
    }

    @Provides
    @Singleton
    fun provideVisualNovelApiService(retrofit: Retrofit): VisualNovelApiService {
        return retrofit.create(VisualNovelApiService::class.java)
    }
}
```

---

### Fix #9: Extract Magic Numbers to Constants

**Problem:** Hard-coded values scattered throughout code.

**Solution:**

**Step 1:** Create constants file:
```kotlin
// util/PresentationConstants.kt
object PresentationConstants {
    // Pagination
    const val MAX_PAGES = 10
    const val INITIAL_PAGE = 0

    // Grid
    const val GRID_COLUMNS_FIXED = 2
    const val GRID_MIN_COLUMN_SIZE_DP = 150

    // Content filtering
    const val EXPLICIT_CONTENT_THRESHOLD = 0.4

    // State retention
    const val STATE_RETENTION_TIMEOUT_MS = 5000L
}
```

**Step 2:** Update `VisualNovelScreen.kt`:
```kotlin
// presentation/screens/VisualNovelScreen.kt
import com.example.vndbapp.util.PresentationConstants

@Composable
private fun VisualNovelListContent(...) {
    val pagerState = rememberPagerState(
        pageCount = { PresentationConstants.MAX_PAGES },
        initialPage = PresentationConstants.INITIAL_PAGE
    )
    // ...
}

@Composable
fun VisualNovelGrid(...) {
    LazyVerticalGrid(
        columns = GridCells.Fixed(PresentationConstants.GRID_COLUMNS_FIXED)
    ) {
        items(visualNovels.filter {
            it.image.explicit < PresentationConstants.EXPLICIT_CONTENT_THRESHOLD
        }) { vn ->
            // ...
        }
    }
}
```

**Step 3:** Update `VisualNovelViewModel.kt`:
```kotlin
import com.example.vndbapp.util.PresentationConstants

val currentPageVns: StateFlow<Resource<List<VisualNovel>>> =
    _currentPage.flatMapLatest { page ->
        localVisualNovelRepository.getVisualNovelsByPage(page = page)
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(PresentationConstants.STATE_RETENTION_TIMEOUT_MS),
        initialValue = Resource.Loading
    )
```

---

### Fix #10: Add Basic Unit Tests

**Problem:** Zero meaningful test coverage.

**Solution:**

**Step 1:** Test mapper functions:
```kotlin
// data/mapper/VisualNovelMapperTest.kt
class VisualNovelMapperTest {

    @Test
    fun `VisualNovel toEntity maps all fields correctly`() {
        val vn = VisualNovel(
            title = "Test VN",
            image = Image(url = "http://test.com", explicit = 0.2),
            id = "v1",
            description = "Test description"
        )

        val entity = vn.toEntity(page = 1)

        assertEquals("v1", entity.id)
        assertEquals("Test VN", entity.title)
        assertEquals("Test description", entity.description)
        assertEquals("http://test.com", entity.imageUrl)
        assertEquals(0.2, entity.explicit)
        assertEquals(1, entity.page)
    }

    @Test
    fun `VisualNovelEntity toModel maps all fields correctly`() {
        val entity = VisualNovelEntity(
            id = "v1",
            title = "Test VN",
            description = "Test description",
            imageUrl = "http://test.com",
            thumbnailUrl = null,
            explicit = 0.2,
            page = 1
        )

        val model = entity.toModel()

        assertEquals("v1", model.id)
        assertEquals("Test VN", model.title)
        assertEquals("http://test.com", model.image.url)
        assertEquals(0.2, model.image.explicit)
    }
}
```

**Step 2:** Test ViewModel:
```kotlin
// presentation/viewmodel/VisualNovelViewModelTest.kt
@ExperimentalCoroutinesApi
class VisualNovelViewModelTest {

    private lateinit var viewModel: VisualNovelViewModel
    private lateinit var mockRepository: VisualNovelRepository

    @BeforeEach
    fun setup() {
        mockRepository = mockk()
        viewModel = VisualNovelViewModel(mockRepository)
    }

    @Test
    fun `loadPage emits loading then success states`() = runTest {
        // Given
        val expectedEntities = listOf(
            VisualNovelEntity(id = "v1", title = "Test", description = "",
                imageUrl = null, thumbnailUrl = null, explicit = 0.1, page = 1)
        )
        val flow = flow {
            emit(Resource.Loading)
            emit(Resource.Success(expectedEntities))
        }
        every { mockRepository.getVisualNovelsByPage(1) } returns flow

        // When
        viewModel.loadPage(1)

        // Then
        val states = mutableListOf<Resource<List<VisualNovelEntity>>>()
        val job = launch {
            viewModel.currentPageVns.toList(states)
        }
        advanceUntilIdle()
        job.cancel()

        assertTrue(states[0] is Resource.Loading)
        assertTrue(states[1] is Resource.Success)
    }
}
```

**Step 3:** Update `build.gradle.kts` for testing:
```kotlin
testImplementation("io.mockk:mockk:1.13.8")
testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")
testImplementation("app.cash.turbine:turbine:1.0.0")
```

---

### Fix #11: Implement Cache Invalidation Strategy

**Problem:** Data cached forever with no freshness check.

**Solution:**

**Step 1:** Add timestamp to entity:
```kotlin
// data/local/entity/VisualNovelEntity.kt
@Entity(tableName = "visual_novels")
data class VisualNovelEntity(
    @PrimaryKey val id: String,
    val title: String,
    val description: String,
    val imageUrl: String?,
    val thumbnailUrl: String?,
    val explicit: Double,
    val page: Int,
    val cachedAt: Long = System.currentTimeMillis()  // ✅ Add timestamp
)
```

**Step 2:** Update mapper:
```kotlin
// data/mapper/VisualNovelMapper.kt
fun VisualNovel.toEntity(page: Int): VisualNovelEntity {
    return VisualNovelEntity(
        id = id,
        title = title,
        description = description,
        imageUrl = image.url,
        thumbnailUrl = image.thumbnail,
        explicit = image.explicit,
        page = page,
        cachedAt = System.currentTimeMillis()  // ✅ Add timestamp
    )
}
```

**Step 3:** Add cache freshness constant and check:
```kotlin
// data/repository/VisualNovelRepositoryImpl.kt
companion object {
    private const val CACHE_FRESHNESS_MS = 24 * 60 * 60 * 1000L // 24 hours
}

override suspend fun getVisualNovelsByPage(page: Int): Flow<Resource<List<VisualNovelEntity>>> = flow {
    emit(Resource.Loading)

    val cached = visualNovelDao.getVisualNovelsByPage(page).first()
    val now = System.currentTimeMillis()

    // Check if cache is stale
    val isStale = cached.isEmpty() ||
        cached.any { now - it.cachedAt > CACHE_FRESHNESS_MS }

    if (cached.isNotEmpty()) {
        emit(Resource.Success(cached))
    }

    if (isStale) {
        // Fetch from network...
    }
}
```

---

## Phase 4: LOW PRIORITY (Refinements)

### Fix #12: Make Grid Responsive

**Current Code:**
```kotlin
LazyVerticalGrid(columns = GridCells.Fixed(2)) { ... }
```

**Solution:**
```kotlin
LazyVerticalGrid(
    columns = GridCells.Adaptive(minSize = 150.dp)
) { ... }
```

---

### Fix #13: Dynamic Pagination

**Current Code:**
```kotlin
val pagerState = rememberPagerState(pageCount = { 10 }, initialPage = 0)
```

**Solution:**
```kotlin
// In ViewModel
val maxPages: StateFlow<Int> = repository.getMaxPages()
    .stateIn(viewModelScope, SharingStarted.Eagerly, 1)

// In UI
val pagerState = rememberPagerState(
    pageCount = { viewModel.maxPages.collectAsState().value },
    initialPage = 0
)
```

---

### Fix #14: Add Retry Logic

**Solution:**
```kotlin
// data/util/RetryUtil.kt
suspend fun <T> retryWithBackoff(
    times: Int = 3,
    initialDelayMs: Long = 1000,
    block: suspend () -> T
): T {
    var currentDelay = initialDelayMs
    repeat(times - 1) {
        try {
            return block()
        } catch (e: Exception) {
            Timber.w(e, "Retrying after ${currentDelay}ms")
            delay(currentDelay)
            currentDelay *= 2
        }
    }
    return block() // Last attempt
}
```

---

## Verification Plan

After implementing all fixes:

1. **Build the app**: `./gradlew assembleDebug`
2. **Run unit tests**: `./gradlew test`
3. **Run instrumented tests**: `./gradlew connectedAndroidTest`
4. **Manual testing**:
   - Open app with no network → Should see cached data
   - Open app with network → Should load fresh data
   - Trigger error (turn off wifi) → Should show error UI with retry button
   - Test pagination → Should load new pages correctly
5. **Check logs** → Verify Timber logging works
6. **Code review** → Verify no `printStackTrace()` remains

---

## Files to Modify Summary

| File | Action | Changes |
|------|--------|---------|
| `data/model/Resource.kt` | CREATE | New wrapper class |
| `data/repository/VisualNovelRepository.kt` | CREATE | Unified interface |
| `data/repository/VisualNovelRepositoryImpl.kt` | CREATE | Unified implementation |
| `domain/usecase/GetVisualNovelsByPageUseCase.kt` | CREATE | Use case |
| `domain/util/Constants.kt` | CREATE | Domain constants |
| `util/PresentationConstants.kt` | CREATE | UI constants |
| `presentation/viewmodel/VisualNovelViewModel.kt` | MODIFY | Use interface, use Resource |
| `presentation/screens/VisualNovelScreen.kt` | MODIFY | Handle Resource states |
| `data/model/VisualNovel.kt` | MODIFY | kotlinx.serialization only |
| `di/AppModule.kt` | MODIFY | Bind new repository |
| `di/RetrofitModule.kt` | MODIFY | Use kotlinx.serialization |
| `VNDBApplication.kt` | MODIFY | Add Timber |
| `data/mapper/VisualNovelMapper.kt` | MODIFY | Add timestamp |
| `data/local/entity/VisualNovelEntity.kt` | MODIFY | Add cachedAt field |

| Files to DELETE |
|-----------------|
| `data/local/repository/LocalVisualNovelRepository.kt` |
| `data/local/repository/LocalVisualNovelRepositoryImpl.kt` |
| `data/remote/repository/VisualNovelRepository.kt` |
| `data/remote/repository/VisualNovelRepositoryImpl.kt` |
| `presentation/viewmodel/VisualNovelEvent.kt` |
| `utils/ApiConstants.kt` (consolidate into Constants) |

---

## Implementation Order

1. **Week 1**: Phase 1 (Critical Fixes)
   - Fix #1: Resource wrapper + error handling
   - Fix #2: ViewModel dependency injection
   - Fix #3: UI states
   - Fix #4: Logging

2. **Week 2**: Phase 2 (Architecture)
   - Fix #5: Unified repository
   - Fix #6: Domain layer + use cases
   - Fix #7: Remove dead code

3. **Week 3**: Phase 3 (Code Quality)
   - Fix #8: Single serialization library
   - Fix #9: Extract constants
   - Fix #10: Add unit tests
   - Fix #11: Cache invalidation

4. **Week 4**: Phase 4 (Refinements)
   - Fix #12-14: Responsive UI, pagination, retry logic

---

*My Eye of Mystery Prying sees these improvements will transform your codebase from fragile to resilient. The threads are clear—follow them, and your architecture shall be strengthened.*
